# Programming Concepts - Parts of Code

## Variables

A **variable**, as in mathematics, is an unknown quantity. Unknown, that is, at the time you are writing the code. The program will know what value it holds when it actually runs. Although different languages use different conventions for variables, the key idea is always the same – it's a name you use to refer to a piece of data. Setting a variable to a value is called **assigning** the value to the variable. The same data can be assigned to multiple different variables at once. Assigning a new value to a variable replaces any existing one. The rules for what constitutes a valid variable name can vary from language to language.

Although the rules for valid variable names vary by programming language, in almost all cases they cannot contain spaces, and cannot start with a number.

## Keywords

Programming languages (with some esoteric exceptions) don't just run on numbers and symbols. Some words have a specific meaning to the programming language, called **keywords**. *Which* words are keywords comes down to the language in question, but an important factor to bear in mind is that you usually can't use keywords as names for other things, such as variables, and even if you can you probably shouldn't. Some languages have extensive lists of keywords, and if you accidentally pick one as a variable name you will probably encounter a syntax error. The error may seem unrelated to the code you have written if it's an error generated by how the language expects you to use that keyword.

## Operators

An **operator** in programming terms is very similar to an operator in the mathematical sense. An operator takes one or more inputs and produces an output. The addition symbol, `+`, is an operator. It takes two inputs, one on either side, and produces their sum as its output. The other three rules of arithmetic are also operators, as you would expect, almost universally treated the same by programming languages.

More advanced operations, such as raising a number to a certain power, are unfortunately much less consistent between programming languages.

The exclamation point `!` is often an operator, used to denote negation – i.e. turning True into False and vice versa.

A common mistep involves the equals symbol `=`. In most languages, it's used to *assign* a value to a variable, and if you try to to use it as a test for equality it will either be a syntax error or result in strange behaviour.

## Organising Code

Despite what film and TV might have you believe, programming is not a process of typing page after page of closely-written, inpenetrable gobbledegook. An important part of programming is *organising* your code, not in terms of files but in terms of the code itself.

Most programming languages have a means of creating a *block* of code. There's nothing special about such a block; it's just some ordinary lines of code with a little fence around them to indicate that, conceptually, they belong together or combine to perform a particular task. Blocks can contain other blocks inside them. In fact, your entire program or script is a block of code in this sense.

It's rare to see blocks defined just by themselves. They're usually seen as part of programming structure. The `if` statement, in most languages, lets you control which code gets run depending on what value a variable holds. The code that gets run when the `if` statement is true will be a block of code. Similarly, the code inside *functions* (the next section) is a block of code.

## Functions

There's a temptation, when starting out, to take lines of code you know work and copy-pasting them into another part of your program where you need to accomplish the same thing. After all, you know those lines work. The reason this is a trap is that if (or perhaps, when) you need to adjust that code slightly you need to remember to update both copies. The more places you pasted that code, the likelier it becomes that you will forget one of them. To avoid this, programmers write that code *once*, then **call** that code wherever they need to. Then, if you need to alter it, you only need to do so once to be assured that the correct version will run everywhere.

Programming languages differ on what name they uses, but some terms are **function**, **method** and **subroutine**. Libraries are usually in the form of extra functions you can call once you import it, but is usual practice to need to write functions specific to your program. Although the rest of this section talks about defining functions yourself, the terminology and rules are also useful even if you only plan on using functions other people have written.

When you **define** a function, the code inside the function does not run at that time. It's only run when the function is called. In compiled languages, these functions are created as part of compilation, so you don't have to worry about where you actually define a function as long as it's defined somewhere. Interpreted languages have no mechanism for looking ahead in the code to see if something is defined later, so you need to make sure you define functions before you use them.

Although the specifics vary, in all languages creating a function involves the following:

### Names

The **name** of the function is used to call it. The most common syntax is to use parentheses (round brackets) after the functions name: `my_function()`.

In some languages, functions are simply a special type of variable, and through assignment you can give a function multiple names or over-write a function by assigning a new one to that name. This is rarely useful in practice, but can be a source of errors when you do so accidentally.

### Arguments

Many (but not all) functions need **arguments** as input. You decide how many arguments a function has, and what to call them. They are variables, but only visible inside the code of the function itself.

When you call the function, you need to put the correct number of arguments inside the brackets to match how you defined the function, and in the correct order. For example, calling a function with `my_function(1, 2, 3)` assumes the function is defined as having 3 arguments, and they will be matched to the variables inside the function in that order.

Some languages allow you to define **default values** for arguments. In this case, if you don't don't specify an argument when you call the function, it will be given the default value. Some languages allow you to use **named arguments**, that is, make it clear when you call a function which argument is being given this value. In practice, it looks something like this: `my_function(1, three=3, two=2)`, assuming the function is defined to have arguments called 'two' and 'three'. Some languages, such as python and R, have both default values for arguments and named arguments.

### Code

The **body** of the function is a block of code. Any variables you create inside this block will be discarded when the function exits. Values are not preserved between different calls of the function. If you assign to new values to the arguments, that will only count inside the function.

If you're wondering what happens when you give a variable inside a function the same name as a variable outside, the answer is "it depends". The details are language-specific and can get rather complicated, and the subject as a whole is called **scope**.

### Return Value

If arguments are the input to a function, the **return value** is the output. Usually a function is called in order to do something with this return value, such as assign it to a variable or use it as an argument for another function. Not every function has a return value.

Only a single value can be returned from a function. However, many languages have a feature that allows you to cheat and wrap several values up together as a single return value. In such cases, it's usual to immediately break them apart into separate variables after calling the function.

### Side Effects

At its simplest, a function takes some arguments and spits out a return value, changing nothing else. However, there are many cases where a function *will* make such a change; updating the value of a variable outside itself, generating a random number and hence changing the state of the random number generator, writing to a file. When a function does this, it is called a **side effect** of the function. The term is misleading because in most cases, this "side effect" is the entire purpose of the function in the first place.

## Expressions

An important idea in programming is the equivalence between a function or an operator and the value it returns. The term for a snippet of code with a return value is an **expression**. Expressions are valid arguments for functions and operators, provided that the value returned is appropriate. This is intuitively obvious when it comes to operators, because we are used to seeing mathematical constructions like `a+b*(c-d)`. However, you can do the same thing with functions. It's valid to have a line of code like `some_function(some_other_function(a,b),c) + a_third_function(d*e)`.

In fact, unless you need to use the return value of a function in multiple places, it's preferred to structure your code like this rather than store the return value then use it only once. If you have a particularly complicated line of code, with expressions nested inside each other, it may still be better to break it into multiple lines for clarity.